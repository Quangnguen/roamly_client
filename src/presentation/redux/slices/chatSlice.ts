import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { dependencies } from '@/src/dependencies/dependencies';
import { ConversationResponseInterface } from '@/src/types/ConversationResponseInterface';
import { MessageResponseInterface, SendMessageRequest } from '@/src/types/messageResponseInterface';

interface ChatState {
    loading: boolean;
    messagesLoading: boolean; // Loading ri√™ng cho messages
    error: string | null;
    conversations: ConversationResponseInterface[];
    selectedConversation: ConversationResponseInterface | null;
    messages: MessageResponseInterface[]; // Th√™m state cho messages
    unreadCount: number;
    onlineUsers: string[];
    hasMoreMessages: boolean; // Flag ƒë·ªÉ ki·ªÉm tra c√≥ c√≤n messages ƒë·ªÉ load kh√¥ng
    currentPage: number; // Trang hi·ªán t·∫°i cho pagination
}

const initialState: ChatState = {
    loading: false,
    messagesLoading: false,
    error: null,
    conversations: [],
    selectedConversation: null,
    messages: [],
    unreadCount: 0,
    onlineUsers: [],
    hasMoreMessages: true,
    currentPage: 1
};

// Async thunk ƒë·ªÉ l·∫•y danh s√°ch conversations
export const getConversations = createAsyncThunk(
    'chat/getConversations',
    async (_, { rejectWithValue }) => {
        try {
            const response: ConversationResponseInterface[] = await dependencies.chatUsecase.getConversations();
            return response;
        } catch (error: any) {
            return rejectWithValue(error.message || 'Failed to get conversations');
        }
    }
);

export const getMessages = createAsyncThunk(
    'chat/getMessages',
    async ({ conversationId, limit, before }: { conversationId: string, limit: number, before?: string }, { rejectWithValue }) => {
        try {
            const response: MessageResponseInterface[] = await dependencies.chatUsecase.getMessages(conversationId, limit, before || '');
            console.log('üîß ChatDetailPage - Messages state updated:', {
                messagesCount: response.length,
                messagesLoading: false,
                hasMoreMessages: true,
                currentPage: 1,
                messages: response.slice(0, 3) // Log first 3 messages
            });
            return { messages: response, conversationId, isLoadMore: !!before };
        } catch (error: any) {
            return rejectWithValue(error.message || 'Failed to get messages');
        }
    }
);

// Async thunk ƒë·ªÉ g·ª≠i tin nh·∫Øn
export const sendMessage = createAsyncThunk(
    'chat/sendMessage',
    async (messageData: SendMessageRequest, { rejectWithValue }) => {
        try {
            const response: MessageResponseInterface = await dependencies.chatUsecase.sendMessage(
                messageData.conversationId,
                messageData.content,
                messageData.files
            );
            return response;
        } catch (error: any) {
            return rejectWithValue(error.message || 'Failed to send message');
        }
    }
);

const chatSlice = createSlice({
    name: 'chat',
    initialState,
    reducers: {
        // Set selected conversation
        setSelectedConversation: (state, action: PayloadAction<ConversationResponseInterface | null>) => {
            state.selectedConversation = action.payload;
            // Reset messages khi ch·ªçn conversation m·ªõi
            state.messages = [];
            state.hasMoreMessages = true;
            state.currentPage = 1;
        },

        // Clear selected conversation
        clearSelectedConversation: (state) => {
            state.selectedConversation = null;
            state.messages = [];
            state.hasMoreMessages = true;
            state.currentPage = 1;
        },

        // Add new message to current conversation
        addMessage: (state, action: PayloadAction<MessageResponseInterface>) => {
            const newMessage = action.payload;
            // Th√™m message v√†o cu·ªëi danh s√°ch (newest last)
            state.messages.push(newMessage);
        },

        // Socket event handlers
        handleSocketNewMessage: (state, action) => {
            console.log('üîÑ chatSlice: handleSocketNewMessage called with:', action.payload);

            const { conversationId, message } = action.payload;
            console.log('üì® chatSlice: Processing message for conversation:', conversationId);
            console.log('üì® chatSlice: Message content:', message);

            // Find conversation and update lastMessage
            const conversationIndex = state.conversations.findIndex(conv => conv.id === conversationId);
            console.log('üì® chatSlice: Found conversation at index:', conversationIndex);

            if (conversationIndex !== -1) {
                const oldLastMessage = state.conversations[conversationIndex].lastMessage;
                const newLastMessage = message.content || message.text || "Tin nh·∫Øn m·ªõi";

                state.conversations[conversationIndex].lastMessage = newLastMessage;
                console.log('üì® chatSlice: Updated lastMessage from', oldLastMessage, 'to', newLastMessage);

                // Move conversation to top of list
                const conversation = state.conversations[conversationIndex];
                state.conversations.splice(conversationIndex, 1);
                state.conversations.unshift(conversation);
                console.log('üì® chatSlice: Moved conversation to top');
            }

            // Update selected conversation if it matches
            if (state.selectedConversation?.id === conversationId) {
                console.log('üì® chatSlice: Updating selected conversation and adding message to list');
                state.selectedConversation!.lastMessage = message.content || message.text || "Tin nh·∫Øn m·ªõi";
                // Add message to current messages list
                state.messages.push(message);
                console.log('üì® chatSlice: Total messages now:', state.messages.length);
            }

            // Increment unread count if not current conversation
            if (state.selectedConversation?.id !== conversationId) {
                state.unreadCount += 1;
                console.log('üì® chatSlice: Incremented unread count to:', state.unreadCount);
            }

            console.log('‚úÖ chatSlice: handleSocketNewMessage completed');
        },

        handleSocketUserOnline: (state, action) => {
            const { userId } = action.payload;
            if (!state.onlineUsers.includes(userId)) {
                state.onlineUsers.push(userId);
            }
        },

        handleSocketUserOffline: (state, action) => {
            const { userId } = action.payload;
            state.onlineUsers = state.onlineUsers.filter(id => id !== userId);
        },

        handleSocketTyping: (state, action) => {
            const { conversationId, userId, isTyping } = action.payload;
            // TODO: Implement typing indicator logic
        },

        // Reset unread count
        resetUnreadCount: (state) => {
            state.unreadCount = 0;
        },

        // Clear chat state
        clearChatState: (state) => {
            state.conversations = [];
            state.selectedConversation = null;
            state.messages = [];
            state.unreadCount = 0;
            state.onlineUsers = [];
            state.hasMoreMessages = true;
            state.currentPage = 1;
            state.error = null;
        }
    },
    extraReducers: (builder) => {
        builder
            // Get conversations
            .addCase(getConversations.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(getConversations.fulfilled, (state, action) => {
                state.loading = false;
                state.conversations = action.payload;
                state.error = null;
            })
            .addCase(getConversations.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload as string || action.error.message || 'C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán';
            })

            // Get messages
            .addCase(getMessages.pending, (state) => {
                state.messagesLoading = true;
                state.error = null;
            })
            .addCase(getMessages.fulfilled, (state, action) => {
                state.messagesLoading = false;
                const { messages, isLoadMore } = action.payload;

                if (isLoadMore) {
                    // Prepend older messages to the beginning of the list
                    state.messages = [...messages, ...state.messages];
                    state.currentPage += 1;
                } else {
                    // Replace with new messages (first load)
                    state.messages = messages;
                    state.currentPage = 1;
                }

                // Check if we have more messages to load
                state.hasMoreMessages = messages.length > 0;
                state.error = null;
            })
            .addCase(getMessages.rejected, (state, action) => {
                state.messagesLoading = false;
                state.error = action.payload as string || action.error.message || 'C√≥ l·ªói x·∫£y ra khi l·∫•y tin nh·∫Øn';
            })

            // Send message
            .addCase(sendMessage.pending, (state) => {
                state.loading = true;
                state.error = null;
            })
            .addCase(sendMessage.fulfilled, (state, action) => {
                state.loading = false;
                const newMessage = action.payload;

                // Th√™m message m·ªõi v√†o cu·ªëi danh s√°ch messages
                state.messages.push(newMessage);

                // C·∫≠p nh·∫≠t lastMessage c·ªßa conversation hi·ªán t·∫°i
                if (state.selectedConversation) {
                    state.selectedConversation.lastMessage = newMessage.content || "Tin nh·∫Øn m·ªõi";

                    // C·∫≠p nh·∫≠t conversation trong danh s√°ch
                    const conversationIndex = state.conversations.findIndex(
                        conv => conv.id === state.selectedConversation?.id
                    );
                    if (conversationIndex !== -1) {
                        state.conversations[conversationIndex].lastMessage = newMessage.content || "Tin nh·∫Øn m·ªõi";
                        // Move conversation to top
                        const conversation = state.conversations[conversationIndex];
                        state.conversations.splice(conversationIndex, 1);
                        state.conversations.unshift(conversation);
                    }
                }

                state.error = null;
            })
            .addCase(sendMessage.rejected, (state, action) => {
                state.loading = false;
                state.error = action.payload as string || action.error.message || 'C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn';
            });
    }
});

// Export actions
export const {
    setSelectedConversation,
    clearSelectedConversation,
    addMessage,
    handleSocketNewMessage,
    handleSocketUserOnline,
    handleSocketUserOffline,
    handleSocketTyping,
    resetUnreadCount,
    clearChatState
} = chatSlice.actions;

// Export reducer
export default chatSlice.reducer;
